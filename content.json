{"meta":{"title":"Hexo","subtitle":null,"description":"��¼�����ѧϰ","author":"Mr Li","url":"dog.jpg"},"pages":[],"posts":[{"title":"Excelent Blog","slug":"Excelent-Blog","date":"2018-03-24T13:35:55.000Z","updated":"2018-03-24T14:44:14.303Z","comments":true,"path":"2018/03/24/Excelent-Blog/","link":"","permalink":"dog.jpg/2018/03/24/Excelent-Blog/","excerpt":"","text":"Aileen:http://aileen.top/ Litten:http://litten.me/ Devin:http://zbk1nger.github.io/","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"dog.jpg/tags/随笔/"}]},{"title":"音乐和视频","slug":"音乐和视频","date":"2018-03-24T12:06:44.000Z","updated":"2018-03-24T16:21:18.116Z","comments":true,"path":"2018/03/24/音乐和视频/","link":"","permalink":"dog.jpg/2018/03/24/音乐和视频/","excerpt":"","text":"插入音乐 代码如下 &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=390 height=86 src=&quot;http://music.163.com/m/song?id=432506345&amp;userid=590854430&quot;&gt; &lt;/iframe&gt; 插入视频 Idina Menze和Caleb Hyles激情对唱Let It Go： 代码如下 &lt;iframe height=300 width=380 src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot; frameborder=0 allowfullscreen&gt; &lt;/iframe&gt;","categories":[],"tags":[]},{"title":"gcc编译连接","slug":"gcc编译链接","date":"2018-03-23T12:08:57.000Z","updated":"2018-03-24T14:18:21.974Z","comments":true,"path":"2018/03/23/gcc编译链接/","link":"","permalink":"dog.jpg/2018/03/23/gcc编译链接/","excerpt":"","text":"在Windows的DOS下实现gcc编译和链接这里主要看的是两篇写的很详细的文章 C语言多文件编译初探（一） C语言多文件编译初探（二） 1.首先，你的Windows电脑的编译器需要是gcc,不清楚的话按win+r,输入cmd，打开DOS命令行界面。然后输入gcc -v,这个是用来查看你gcc版本的，如果提示不是内部或外部指令，则你的编译器不是gcc。反之，如果出现如下图片，则可以进行下一步了。 2.如果没有gcc，可以通过下载Dev-C++,使用其bin下的gcc.exe。在环境变量中配置Dev_C++下的bin。 3.此时就可以在DOS中使用gcc了。gcc可以将c/c++文件编译为.o文件，然后链接生成可执行文件.exe。4.接下来我们写两个源文件，一个头文件，用来模拟多文件编译过程。 //创建一个main.c文件 #include&lt;stdio.h&gt; int main() { fun(); return 0; } – //创建一个fun.c文件,用来创建函数 #include&lt;stdio.h&gt; void fun() { int a=3,b=6; printf(&quot;%d+%d=%d&quot;,a,b,a+b); } – //创建一个fun.h文件，用来声明fun()这个函数 //这个就很简单 void fun(); 5.接下来就到关键时刻了，先生成.o文件，命令是gcc -c fun.c main.c,前面-c是指只执行编译这一步，如果没有，就会直接生成.exe文件。这里是为了便于理解。执行完这一步，会发现源代码文件夹下有fun.o和main.o这两个文件，这就是目标文件，即二进制文件。下一步链接就需要这两个目标文件。 6.链接命令是gcc fun.o main.o,这个默认生成的.exe文件是a.exe,如果觉得这样的名字不好，可以自己命名，只需要在后面加个-o name.exe即可。例如gcc fun.o main.o -o mine.exe,执行完后源代码目录下就会有.exe文件生产。最终所有文件如下： 以上就是gcc编译链接多文件的流程","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"dog.jpg/tags/技术/"}]},{"title":"车牌识别","slug":"车牌识别","date":"2018-03-20T14:26:22.000Z","updated":"2018-03-24T14:19:25.359Z","comments":true,"path":"2018/03/20/车牌识别/","link":"","permalink":"dog.jpg/2018/03/20/车牌识别/","excerpt":"","text":"一、车牌定位代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;opencv2\\opencv.hpp&quot;#include &lt;iostream&gt;using namespace std; using namespace cv;int main()&#123; //定义，类似define string xmlPath = &quot;cascade.xml&quot;; //创建分类器对象 CascadeClassifier ccf; Mat img = imread(&quot;1.jpg&quot;); //加载训练文件 if (!ccf.load(xmlPath)) &#123; cout &lt;&lt; &quot;不能加载指定的xml文件&quot; &lt;&lt; endl; return 0; &#125; //创建一个容器保存检测出来的车牌 vector&lt;Rect&gt; faces; Mat gray; //转换成灰度图，因为harr特征从灰度图中提取 cvtColor(img, gray, CV_BGR2GRAY); //直方图均衡行 equalizeHist(gray, gray); //检测车牌 ccf.detectMultiScale(gray, faces, 1.1, 3, 0, Size(1, 10), Size(1000, 1000)); imshow(&quot;chepai&quot;, faces); for (vector&lt;Rect&gt;::const_iterator iter = faces.begin();iter != faces.end ();iter++) &#123; //画出车牌矩形 rectangle(img, *iter, Scalar(0, 0, 255), 2, 8); &#125; //imshow(&quot;rect&quot;, Rect); //resize(img, img, Size(1018, 550)); imshow(&quot;plate&quot;, img); waitKey(0); return 1;&#125; 结果如图 二、车牌字符识别 代码参考来自:https://www.cnblogs.com/chenzhefan/p/7629441.html 由于他使用的OpenCV版比较早，有些语法功能有稍微改变，但具体思路很详细。 ANN模型训练123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138void ann10(Mat&amp; testroi)&#123; const string fileform = &quot;*.png&quot;; const string perfileReadPath = &quot;E:\\\\vswork\\\\charSamples&quot;; const int sample_mun_perclass = 50;//训练字符每类数量 const int class_mun = 34;//训练字符类数 0-9 A-Z 除了I、O const int image_cols = 8; const int image_rows = 16; string fileReadName,fileReadPath; char temp[256]; float trainingData[class_mun*sample_mun_perclass][image_rows*image_cols] = &#123; &#123; 0 &#125; &#125;;//每一行一个训练样本 float labels[class_mun*sample_mun_perclass][class_mun] = &#123; &#123; 0 &#125; &#125;;//训练样本标签 for (int i = 0; i &lt;= class_mun - 1; i++)//不同类 &#123; //读取每个类文件夹下所有图像 int j = 0;//每一类读取图像个数计数 if (i &lt;= 9)//0-9 &#123; sprintf(temp, &quot;%d&quot;, i); //printf(&quot;%d\\n&quot;, i); &#125; else//A-Z &#123; sprintf(temp, &quot;%c&quot;, i + 55); //printf(&quot;%c\\n&quot;, i+55); &#125; fileReadPath = perfileReadPath + &quot;/&quot; + temp + &quot;/&quot; + fileform; cout &lt;&lt; &quot;文件夹&quot; &lt;&lt; fileReadPath &lt;&lt; endl; HANDLE hFile; LPCTSTR lpFileName = StringToWchar(fileReadPath);//指定搜索目录和文件类型，如搜索d盘的音频文件可以是&quot;D:\\\\*.mp3&quot; WIN32_FIND_DATA pNextInfo; //搜索得到的文件信息将储存在pNextInfo中; hFile = FindFirstFile(lpFileName, &amp;pNextInfo);//请注意是 &amp;pNextInfo , 不是 pNextInfo; if (hFile == INVALID_HANDLE_VALUE) &#123; continue;//搜索失败 &#125; //do-while循环读取 do &#123; if (pNextInfo.cFileName[0] == &apos;.&apos;)//过滤.和.. continue; j++;//读取一张图 //wcout&lt;&lt;pNextInfo.cFileName&lt;&lt;endl; //printf(&quot;%s\\n&quot;,WcharToChar(pNextInfo.cFileName)); //对读入的图片进行处理 Mat srcImage = imread(perfileReadPath + &quot;/&quot; + temp + &quot;/&quot; + WcharToChar(pNextInfo.cFileName), CV_LOAD_IMAGE_GRAYSCALE); Mat resizeImage; Mat trainImage; Mat result; resize(srcImage, resizeImage, Size(image_cols, image_rows), (0, 0), (0, 0), CV_INTER_AREA);//使用象素关系重采样。当图像缩小时候，该方法可以避免波纹出现 threshold(resizeImage, trainImage, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU); for (int k = 0; k&lt;image_rows*image_cols; ++k) &#123; trainingData[i*sample_mun_perclass + (j - 1)][k] = (float)trainImage.data[k]; //trainingData[i*sample_mun_perclass+(j-1)][k] = (float)trainImage.at&lt;unsigned char&gt;((int)k/8,(int)k%8);//(float)train_image.data[k]; //cout&lt;&lt;trainingData[i*sample_mun_perclass+(j-1)][k] &lt;&lt;&quot; &quot;&lt;&lt; (float)trainImage.at&lt;unsigned char&gt;(k/8,k%8)&lt;&lt;endl; &#125; &#125; while (FindNextFile(hFile, &amp;pNextInfo) &amp;&amp; j&lt;sample_mun_perclass);//如果设置读入的图片数量，则以设置的为准，如果图片不够，则读取文件夹下所有图片 &#125; // Set up training data Mat Mat trainingDataMat(class_mun*sample_mun_perclass, image_rows*image_cols, CV_32FC1, trainingData); cout &lt;&lt; &quot;trainingDataMat——OK！&quot; &lt;&lt; endl; // Set up label data for (int i = 0; i &lt;= class_mun - 1; ++i) &#123; for (int j = 0; j &lt;= sample_mun_perclass - 1; ++j) &#123; for (int k = 0; k &lt; class_mun; ++k) &#123; if (k == i) if (k == 18) &#123; labels[i*sample_mun_perclass + j][1] = 1; &#125; else if (k == 24) &#123; labels[i*sample_mun_perclass + j][0] = 1; &#125; else &#123; labels[i*sample_mun_perclass + j][k] = 1; &#125; else labels[i*sample_mun_perclass + j][k] = 0; &#125; &#125; &#125; Mat labelsMat(class_mun*sample_mun_perclass, class_mun, CV_32FC1, labels); cout &lt;&lt; &quot;labelsMat:&quot; &lt;&lt; endl; ofstream outfile(&quot;out.txt&quot;); outfile &lt;&lt; labelsMat; //cout&lt;&lt;labelsMat&lt;&lt;endl; cout &lt;&lt; &quot;labelsMat——OK！&quot; &lt;&lt; endl; //训练代码 cout &lt;&lt; &quot;training start....&quot; &lt;&lt; endl; CvANN_MLP bp; // Set up BPNetwork&apos;s parameters CvANN_MLP_TrainParams params; params.train_method = CvANN_MLP_TrainParams::BACKPROP; params.bp_dw_scale = 0.001; params.bp_moment_scale = 0.1; params.term_crit = cvTermCriteria(CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, 10000, 0.0001); //设置结束条件 //params.train_method=CvANN_MLP_TrainParams::RPROP; //params.rp_dw0 = 0.1; //params.rp_dw_plus = 1.2; //params.rp_dw_minus = 0.5; //params.rp_dw_min = FLT_EPSILON; //params.rp_dw_max = 50.; //Setup the BPNetwork Mat layerSizes = (Mat_&lt;int&gt;(1, 5) &lt;&lt; image_rows*image_cols, 128, 128, 128, class_mun); bp.create(layerSizes, CvANN_MLP::SIGMOID_SYM, 1.0, 1.0);//CvANN_MLP::SIGMOID_SYM //CvANN_MLP::GAUSSIAN //CvANN_MLP::IDENTITY cout &lt;&lt; &quot;training....&quot; &lt;&lt; endl; bp.train(trainingDataMat, labelsMat, Mat(), Mat(), params); bp.save(&quot;../bpcharModel.xml&quot;); //save classifier cout &lt;&lt; &quot;training finish...bpModel.xml saved &quot; &lt;&lt; endl; return;&#125; ANN+Predict1234567891011121314151617181920212223242526272829303132333435363738394041424344void predictann(Mat testroi)&#123; //测试神经网络 CvANN_MLP bp; bp.load(&quot;E:\\\\vswork\\\\CarNumRecog\\\\bpcharModel.xml&quot;); const int image_cols = 8; const int image_rows = 16; cout &lt;&lt; &quot;测试：&quot; &lt;&lt; endl; //Mat test_image = imread(&quot;E:\\\\vswork\\\\charSamples\\\\3.png&quot;, CV_LOAD_IMAGE_GRAYSCALE); Mat test_temp; resize(testroi, test_temp, Size(image_cols, image_rows), (0, 0), (0, 0), CV_INTER_AREA);//使用象素关系重采样。当图像缩小时候，该方法可以避免波纹出现 threshold(test_temp, test_temp, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU); Mat_&lt;float&gt;sampleMat(1, image_rows*image_cols); for (int i = 0; i&lt;image_rows*image_cols; ++i) &#123; sampleMat.at&lt;float&gt;(0, i) = (float)test_temp.at&lt;uchar&gt;(i / 8, i % 8); &#125; Mat responseMat; bp.predict(sampleMat, responseMat); Point maxLoc; double maxVal = 0; minMaxLoc(responseMat, NULL, &amp;maxVal, NULL, &amp;maxLoc); char temp[256]; if (maxLoc.x &lt;= 9)//0-9 &#123; sprintf(temp, &quot;%d&quot;, maxLoc.x); //printf(&quot;%d\\n&quot;, i); &#125; else//A-Z &#123; sprintf(temp, &quot;%c&quot;, maxLoc.x + 55); //printf(&quot;%c\\n&quot;, i+55); &#125; cout &lt;&lt; &quot;识别结果：&quot; &lt;&lt; temp &lt;&lt; &quot; 相似度:&quot; &lt;&lt; maxVal * 100 &lt;&lt; &quot;%&quot; &lt;&lt; endl; imshow(&quot;test_image&quot;, testroi); waitKey(0); return;&#125;","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"dog.jpg/tags/技术/"}]},{"title":"机器学习","slug":"机器学习","date":"2018-03-20T05:08:11.000Z","updated":"2018-03-24T14:19:57.767Z","comments":true,"path":"2018/03/20/机器学习/","link":"","permalink":"dog.jpg/2018/03/20/机器学习/","excerpt":"","text":"一、ANN、SVM模型训练及使用的代码提示：以下基于opencv3 由于我没有接触过类似于Tensorflow的深度学习框架，所以下面了解的知识还比较片面。除TensorFlow外，深度学习的框架还有：Caffe、Keras、CNTK、Torch7、MXNet、Leaf、Theano、DeepLearning4、Lasagne、Neon，等等 关于用TensorFlow训练模型的文章 opencv和Tensorflow的区别 OpenCV是计算机视觉库，Tensorflow是深度学习框架。 OpenCV包含了大量的图像处理和计算机视觉的算法，但是在机器学习方面明显不足，ML模块只有SVM，MLP（opencv的神经网络—多层感知器），kNN等有限的几种算法。dnn模块也是调用别的框架。 Tensorflow是专为深度学习而生，可以方便的实现各种深度学习算法。 二者不属于同一领域，做视觉用OpenCV，做深度学习用Tensorflow。或者二者结合做图像识别等等。 ANN模型训练 ANN模型使用参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int ANN_TEST()&#123; // 540 x 360 矩阵（为输入图片的尺寸） int smpW = 540; int smpH = 360; // 每个样本数据对应的输出 float labels[8] = &#123; 0,0,0,0,1,1,1,1 &#125;; //第一个数据：标签个数 Mat labelsMat(8, 1, CV_32FC1, labels); cout &lt;&lt; labelsMat &lt;&lt; endl; // 训练样本 Mat trainMat(8, smpW * smpH, CV_32FC1); for (int i = 0; i &lt; 2; i++) &#123; for (int j = 1; j &lt; 5; j++) &#123; //批量读取图片，因为8张图片，故没有转化为.txt格式 string path = format(&quot;%d%d.jpg&quot;, i, j); Mat img = imread(path, 0); if (img.empty()) &#123; return 0; &#125; int index1 = i * 4 + j - 1; float * trainData = trainMat.ptr&lt;float&gt;(index1); for (int h = 0; h &lt; smpH; h++) &#123; uchar * imgData = img.ptr&lt;uchar&gt;(h); for (int w = 0; w &lt; smpW; w++) &#123; int index2 = h*smpW + w; trainData[index2] = imgData[w]; &#125; &#125; &#125; &#125; //模型创建和参数设置 Ptr&lt;ANN_MLP&gt; bp = ANN_MLP::create(); //设置神经网络层数 Mat layerSizes = (Mat_&lt;int&gt;(1, 5) &lt;&lt; smpW * smpH, 128, 128, 128, 1); bp-&gt;setLayerSizes(layerSizes); bp-&gt;setTrainMethod(ANN_MLP::BACKPROP, 0.1, 0.1); bp-&gt;setActivationFunction(ANN_MLP::SIGMOID_SYM); bp-&gt;setTermCriteria(TermCriteria(TermCriteria::MAX_ITER, 10000, /*FLT_EPSILON*/1e-6)); // 保存训练好的神经网络参数 bool trained = bp-&gt;train(trainMat, ROW_SAMPLE, labelsMat); if (trained) &#123; bp-&gt;save(&quot;bp_param_bymyself.xml&quot;); &#125;&#125; ANN模型调用 123456789101112131415161718192021222324252627282930313233//创建并调用训练好的ANN神经网络Ptr&lt;ANN_MLP&gt; bp = ANN_MLP::load(&quot;bp_param.xml&quot;);for (int i = 0; i &lt; 2; i++)&#123; for (int j = 5; j &lt; 6; j++) &#123; Mat testMat(1, smpW * smpH, CV_32FC1); float * testData = testMat.ptr&lt;float&gt;(0); //读取图片 string path = format(&quot;%d%d.png&quot;, i, j); Mat img = imread(path, 0); for (int h = 0; h &lt; smpH; h++) &#123; uchar * imgData = img.ptr&lt;uchar&gt;(h); for (int w = 0; w &lt; smpW; w++) &#123; int index2 = h*smpW + w; testData[index2] = imgData[w] * 1.0; &#125; &#125; Mat responseMat; //通过模型进行预测 bp-&gt;predict(testMat, responseMat); float response = responseMat.ptr&lt;float&gt;(0)[0]; cout &lt;&lt; response &lt;&lt; endl; float * data = responseMat.ptr&lt;float&gt;(0); cout &lt;&lt; data[0] &lt;&lt; endl; waitKey(10); &#125;&#125; SVM模型训练123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int SVM()&#123; //训练2组数据，每组4帧 int labels[8] = &#123; 0, 0, 0, 0, 1, 1, 1, 1 &#125;; Mat labelsMat(8, 1, CV_32SC1, labels); //样本宽高 int smpW = 540; int smpH = 360; //将样本的值逐像素赋给训练图像 Mat trainMat(8, smpW * smpH, CV_32FC1); for (int i = 0; i &lt; 2; i++) &#123; for (int j = 1; j &lt; 5; j++) &#123; string path = format(&quot;%d%d.jpg&quot;, i, j); Mat img = imread(path, 0); int index1 = i * 4 + j - 1; float * trainData = trainMat.ptr&lt;float&gt;(index1); for (int h = 0; h &lt; smpH; h++) &#123; uchar * imgData = img.ptr&lt;uchar&gt;(h); for (int w = 0; w &lt; smpW; w++) &#123; int index2 = h*smpW + w; trainData[index2] = imgData[w]; &#125; &#125; &#125; &#125; Ptr&lt;SVM&gt; svm = SVM::create(); svm-&gt;setType(SVM::C_SVC); svm-&gt;setKernel(SVM::LINEAR); svm-&gt;setTermCriteria(TermCriteria(TermCriteria::MAX_ITER, 100, 1e-6)); ////设置训练数据 Ptr&lt;TrainData&gt; tData = TrainData::create(trainMat, ROW_SAMPLE, labelsMat); svm-&gt;train(tData); svm-&gt;save(&quot;SVM_data.xml&quot;);&#125; SVM模型调用12345678910111213141516171819202122232425262728293031323334int smpW = 540;int smpH = 360;//创建并调用SVM模型Ptr&lt;SVM&gt; svm = SVM::load(&quot;SVM_data.xml&quot;);cout &lt;&lt; &quot;测试&quot; &lt;&lt; endl;for (int i = 0; i &lt; 2; i++)&#123; for (int j = 5; j &lt; 6; j++) &#123; Mat testMat(1, smpW * smpH, CV_32FC1); float * testData = testMat.ptr&lt;float&gt;(0); string path = format(&quot;%d%d.png&quot;, i, j); Mat img = imread(path, 0); Canny(img, img, 50, 100); for (int h = 0; h &lt; smpH; h++) &#123; uchar * imgData = img.ptr&lt;uchar&gt;(h); for (int w = 0; w &lt; smpW; w++) &#123; int index2 = h*smpW + w; testData[index2] = imgData[w] * 1.0; &#125; &#125; Mat ret(1, 1, CV_32S); float response = svm-&gt;predict(testMat, ret); //进行预测，返回1或0 cout &lt;&lt; response &lt;&lt; endl; float * data = ret.ptr&lt;float&gt;(0); cout &lt;&lt; data[0] &lt;&lt; endl; waitKey(10); 二、神经网络训练及工作原理 1.原理 CNN原理解读 原理是：知道初始数据和需要的结果，分别用两个容器存储样本和标签数据，然后输入神经网络，神经网络通过大量数据的训练，使各层间的权值趋于稳定，直至模型训练完成。 目的：当给模型一个数据时，通过之前训练得出的模型，计算结果并输出。 2.训练流程的例子（ANN）前提需要准备好样本，标签的准备最为费时 创建神经网络 设置网络层数和神经元个数 创建两个容器，分别保存样本和标签 读取两个容器中的数据 开始训练模型 保存模型（数据少的话不太费时，多的话可能要一两天） 后期调用 3.样本和标签的批量处理由于样本和标签很多，所以要将他们放在一个地方，读取时就可以实现自动批量处理，这里以csv文件为例。csv是逗号分隔值文件格式，是一种用来存储数据的纯文本文件。目标为数字识别，保存样式为：一行两个数据，第一个为数字图片的存储路径（即样本），第二个为标签（就是图片的数字，比如0,1,2···）具体展示如下。 4.注意事项 ANN神经网络的输入层的端口数要等于样本的像素点，输出层端口数要等于label的个数 理论上网络越深则表达能力越强，能处理的训练数据也更多，但训练算法未必支持 机器学习要想生效，必须满足一个条件，就是目标问题对已有数据可解 三、车牌识别（HyperLPR） 车牌识别中用到机器学习的有两个地方—–&gt;1. 车牌定位 2.车牌字符识别 车牌定位 车牌字符识别","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"dog.jpg/tags/技术/"}]},{"title":"Markdown_note","slug":"Markdown-note","date":"2018-03-18T15:14:21.000Z","updated":"2018-03-24T14:19:42.542Z","comments":true,"path":"2018/03/18/Markdown-note/","link":"","permalink":"dog.jpg/2018/03/18/Markdown-note/","excerpt":"","text":"第二篇 Markdown学习笔记By Lijie上面是一条细横线 也有粗横线与之对应： 是--- 序号部分 与文字间要有空格 其他也没什么重要的 就是这样 着重号 *和-功能一样 加粗 此处也可用快捷键ctrl+B 倾斜 快捷键ctrl+I 代码部分 ctrl+K 删除线 此处不能显示我也不知怎到原因 此处还有引用 千山鸟飞绝，万径人踪灭 《春江花月夜》 图片插入 超出我的预料，特别方便 我再试试输入另外一张图片 圆括号内写图片路径 表格 | 看看 | 可是 | | — | — | | 55 | 66 | 同样是不能显示 最后是链接 百度 自己尝试 我的Github 到此基本功能学习完了","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"dog.jpg/tags/学习笔记/"}]},{"title":"第一次尝试","slug":"第一次尝试","date":"2018-03-16T16:25:59.000Z","updated":"2018-03-24T15:09:45.121Z","comments":true,"path":"2018/03/17/第一次尝试/","link":"","permalink":"dog.jpg/2018/03/17/第一次尝试/","excerpt":"","text":"#很高兴，今天可以自己搭建博客了 ## 1.之前尝试过搭建，都因为工具的原因一直出错。 2.今天下午在ubuntu上尝试，但hexo无法正常下载。然后又用Windows的Git搭建，出现的问题更多。 3.最后在网上看到一篇博客—&gt;http:////blog.csdn.net/gdutxiaoxu/article/details/535760184.他直接使用Windows的DOS,具体操作很详细，过程也能看懂。 博客的发布也很简单：hexo d -g 生成及部署 此处载入一张图片，以表心情 5.希望自己稍后能学会在Linux上搭建博客。 ##","categories":[],"tags":[{"name":"第一次尝试","slug":"第一次尝试","permalink":"dog.jpg/tags/第一次尝试/"}]},{"title":"Hello World","slug":"Hello-World","date":"2018-03-16T11:32:59.000Z","updated":"2018-03-24T13:11:39.007Z","comments":true,"path":"2018/03/16/Hello-World/","link":"","permalink":"dog.jpg/2018/03/16/Hello-World/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}