{"meta":{"title":"Aspire","subtitle":"���֮��","description":"��¼�����ѧϰ","author":"Aspire","url":"dog.jpg"},"pages":[{"title":"相册","date":"2018-03-25T08:26:30.000Z","updated":"2018-03-25T08:29:39.914Z","comments":true,"path":"photo/index.html","permalink":"dog.jpg/photo/index.html","excerpt":"","text":""},{"title":"","date":"2018-03-25T08:32:03.267Z","updated":"2018-03-25T08:32:03.267Z","comments":true,"path":"photo/tool.js","permalink":"dog.jpg/photo/tool.js","excerpt":"","text":"\"use strict\"; const fs = require(\"fs\"); const path = \"../../photos\"; fs.readdir(path, function (err, files) { if (err) { return; } let arr = []; (function iterator(index) { if (index == files.length) { fs.writeFile(\"output.json\", JSON.stringify(arr, null, \"\\t\")); return; } fs.stat(path + \"/\" + files[index], function (err, stats) { if (err) { return; } if (stats.isFile()) { arr.push(files[index]); } iterator(index + 1); }) }(0)); });"}],"posts":[{"title":"pass","slug":"pass","date":"2018-03-30T15:51:49.000Z","updated":"2018-03-30T16:01:39.533Z","comments":true,"path":"2018/03/30/pass/","link":"","permalink":"dog.jpg/2018/03/30/pass/","excerpt":"","text":"看的到？ 、、司机师傅 精神可嘉快速健康健康的数据库 阿富汗何况非法吉娃娃sAHib SKAKWHQHF SAUWERYYGWFEJASJ SAIETFGFG金卡价数据库 暗示法或或或或 十分看好时间时间 圣诞节附加费 精神恍惚或多说多","categories":[],"tags":[]},{"title":"Linux的诞生","slug":"Linux的诞生","date":"2018-03-27T04:41:50.000Z","updated":"2018-03-27T04:56:05.905Z","comments":true,"path":"2018/03/27/Linux的诞生/","link":"","permalink":"dog.jpg/2018/03/27/Linux的诞生/","excerpt":"","text":"摘自微信公众号 你知道Linux系统有多牛吗？ 迄今为止，在全球范围内： 80%以上的智能手机用的都是基于Linux内核的Android系统。 全球超级计算机排名前500中有98%都在用Linux，包括中国制造、世界超算第一的神威太湖之光。 全球大部分证券交易市场都在用Linux，包括纽交所、纳斯达克、伦敦证券交易所、东京证券交易所等 75%的云计算企业报告平台都用Linux 全球主机行业有33.8%的服务器都用Linux，而Windows 系统服务器只占7.3%。 包括亚马逊、易趣网、沃尔玛等电子商务平台都在用Linux…… 换句话说，当今世上大部分的软件和服务都运行在Linux 操作系统之上，各种云计算、大数据、移动互联网，说起来吊炸天，但如果没有Linux，一切都是浮云。 但你肯定想象不到，如此牛到天际的系统却是李纳斯·托沃兹（后文简称“李纳斯”）在经历各种纠结与挣扎之后的无奈发明。 酷爱编程的Linux之父 李纳斯1969年出生于芬兰赫尔辛基，十岁时因外祖父是大学统计学教授的缘故，得以接触计算机。那是一台Commodore VIC-2，在当时为世界上第一批廉价的8位家用电脑。这台电脑除了用Basic语言写程序之外别无它用。起初他只是将外祖父写在纸上的程序录入电脑，但是他天资聪颖，喜欢钻研，帮祖父录完程序后，就开始阅读电脑手册，写里面的示范程序，示范程序写完了，就自己编写程序。 一段时间后，他又开始琢磨电脑是怎样工作的，以及思索如何能让电脑运行得更快…… 就这样三年过去了，在其他孩子都在滑雪、踢足球，进行各类户外游戏时，李纳斯却觉得外公的电脑更有意思了。 这时候的他已经进入了青春期，同龄的男孩子都在被窝里偷偷看playboy杂志，而他却总是在跟妈妈道完晚安之后再偷偷地从床上爬起来，然后打开电脑编程。 编程令他废寝忘食。他的妈妈逢人便说李纳斯是个很好养的孩子，一台电脑加一些意大利面条，就能让他心满意足。就是对女孩子不感兴趣这一点让他的父母非常担心。 他的爸爸给他买了一些模型飞机、轮船、汽车、铁路和模型火车等好玩的玩具，但这些东西远远比不上电脑对他有吸引力。他的父母并不限制他玩电脑，但是在对他的管教方面，却多了一个杀手锏，若是他不听话，只要剥夺他玩电脑的权利，他立马就怂。 上高中后，他的数学成绩非常优秀，那时的女孩子都特别希望能得到“数学天才”的辅导，于是他的父母就发现了让他对女孩子产生兴趣的办法，隔三差五催他带女孩子回家来辅导。 而他自然也是照做了，只是即便这样，直到高中毕业他也没弄明白同学间说的“深度爱抚”是什么意思。为此他特意花了不少时间照顾邻居家一只十五磅重的猫，然后认为“深度爱抚”也没有什么了不起的。 快乐不能久留，纠结与无奈常伴左右 后来Commodore VIC-2李纳斯已经玩得很溜了，便想买一台下一代的电脑。为此他攒了圣诞节和生日时父母给的奖励金，参加了赫尔辛基公司清洁队，当过邮差，再加上学校发的奖学金，在1987年的时候他成功地买下了一台Sinclair QL。 这是世界第一台32位家用计算机，采用摩托罗拉68008处理器，操作系统是Q-DOS。它的BASIC 语言非常先进，图形显示也不赖，且能进行多重任务处理。他用之做了大量编程，还编写了工具性程序。 但是令他无比纠结的是：VIC-2只有一个只读操作系统，无法重编程，而且虽说能进行多重任务处理，但在任何时候都会出现死机，也因为没有保存措施，只要一个任务出现差错，整个机子就死掉了。此外，给这台电脑购买配套设备是个无解的难题，因为他压根儿就找不到Sinclair QL电脑的产品目录！ 第二年，他考上了赫尔辛基大学，主修计算机，数学和物理是辅修。这一年他没怎么写程序。主要是Sinclair QL毛病太多，让他没了心情。大学第二年，他有两个选择：要么在部队服八个月的兵役，要么从事一年的社会服务工作。他选择了去服兵役，因为他觉得在军队服役能更好玩一点。 服兵役也有两个选择：当一个普通大兵，服满要求的八个月或是去一所军官培训学校，当十一个月的军官。他选择了后者，因为他觉得当一名军官可能会更有意思。 1986年的时候386芯片横空出世，它在功能上完美地取代了68020，PC机开始受追捧。而等到1990年的时候，大规模生产使其价格大幅下跌，这让手头拮据的李纳斯看到了希望。 这一年，恰好他服完兵役回校，当时UNIX操作系统因稳定而强大的功能在学术界掀起了的风潮，学校也在这一年引入了UNIX系统，对此他兴奋不已。 虽然他没钱买386，但是他可以让自己的Sinclair QL通过终端仿真进入大学的UNIX电脑，等到有了足够的钱再买自己的也不迟。而UNIX系统果然没有令他失望，他重新在电脑这里找到了快乐。 1991年新年，他以分期付款的方式购买了一台组装PC机。内存他选择了4兆，最大的；CPU他选择了33 兆赫，最好的。不过这台电脑自带的MS-DOS 操作系统让李纳斯很是无奈，因为这套系统甚至无法利用386芯片极大提升的性能。曾经沧海难为水，享受过UNIX的美好，叫他如何还能容忍DOS的low？ 他打心眼里想给这台电脑装UNIX，但不幸的是（却是世界之幸），UNIX太贵了，他完全负担不起！当时MINIX软件，作为UNIX的一个小型克隆也很受人们的追捧，而且价格比UNIX要低很多，他便退而求其次，购买了MINIX软件。而正是他的这一举动，最终促成了Linux后来的诞生！ MINIX软件从订购到拿到手李纳斯用了一个月的时间，但那时的他却感觉如同过了六年一般漫长，他花了大量时间去仔细了解它的功能和用途，最后他成功了解了它好的方面，却在同时也了解了它不好的方面。但最让他不能接受的是，MINIX的终端仿真做得太糟糕了。要知道那时的他只有依赖终端仿真，才能让家里的电脑模仿大学的电脑，从而享受UNIX的强大与稳定。这样的缺陷对他而言简直就是致命的！ 在饱受一番折磨之后，他痛定思痛，最终决定：自己做一个终端仿真！ Linux 诞生！ 这是李纳斯人生中的第一台PC，要做终端仿真，他需要学习很多东西。他从 BIOS 开始学习，了解 CPU 的工作原理，了解怎样写入显示器、怎样读键盘输入、怎样读写调制解调器……后来他想出两条独立的线程：一条线程从调制解调器读出，然后在显示器上显示；另一条线程从键盘上读出，然后写入调制解调器。 他写的最早的试验程序是使用一个线程将字母 A 写到显示器上，另一个线程写B。最后他就能改变由一连串 A 和一连串 B 组成的两个线程，使数据一个读自调制解调器，再写入显示器，另一个读自键盘，再写入调制解调器。到这时，他的终端仿真程序正式宣告制作成功！ 成功之后的那种发自内心的喜悦自然难以言喻。凭借自己的终端仿真器，他经常登录学校的电脑上，查阅电子邮件和参加 MINIX 讨论组。但是好景不长，他很快又发现了一个新问题，那就是：他无法下载和上传东西！也就是说，他必须能够向磁盘里保存东西。若要实现这个功能，他的终端仿真器必须装个磁盘驱动，外加一个文件系统驱动！ 这个时候，即便李纳斯极度渴望这个功能，也未免有些泄气了，因为做这些实在是太麻烦了！也不值得。 只是没过多久他就改变了主意，因为他发现：除此之外他没有什么可做的！大学课程非常简单，无需费太多的心思，同学聚会也让他提不起精神，而搞驱动程序的工作虽然很麻烦，但却很有意思！ 于是，他开始了写磁盘驱动程序的艰苦生涯。每天睁开眼睛后第一件事——编程，饿了就嚼饼干，嚼完继续编程，困了就睡会儿，醒来继续编程，洗澡也就冲冲了事，冲完澡继续编程……没了白天和夜晚，分不清周末还是工作日，电脑之外的世界几乎与他绝缘，在这场马拉松式的编程中，某一天他突然意识到：这项工作已经不再是优化一个终端仿真器，而是再造一个操作系统！ Linux 操作系统就是这样开始的，而他的试验程序则变成了终端仿真组合程序。 又经过数个月的努力之后，外壳程序开发完成，这个时候的他感觉便如创世之时的上帝，只待说出“要有光”一样执掌一切。当他把外壳程序移到一个他为新的操作系统所建的特别区域中后，一个新的操作系统宣告了诞生！他将其命名为“Linux”！ 然后，他毫不犹豫地就将Linux发布出去了，因为他一直有与人交流程序的习惯。 在那时的PC世界中，有一个有关软件共享的传统，就是你下载了一个程序，就应该给作者寄回十块钱左右的回报。但李纳斯并不想要钱，他只想要明信片，因为与钱相比，他更想知道都有哪儿的人在使用 Linux，结果他收到了逾百万张明信片。 而他当初买电脑时的欠款则在一个朋友的帮助下，成功地从一项网上募捐行动中得到了解决……为嘛这事儿听起来这么有喜感？ 但是这时候的Linux并未脱离MINIX而存在，似乎上帝对这样的结果仍不满意，便推了他一把：他在接下来的某一天出现操作失误，将MINIX分区破坏了！这个时候他可以选择重装MINIX，也可以通过完善Linux来彻底取代MINIX。他选择了后者，因为他觉得Linux已经足够好。 于是，从这时起，人们开始用Linux来做些事了。 因为开源的缘故，Linux 的用户开始与日俱增，获得了巨大的发展，世界各地的程序员们每天都在共同分享彼此提出的修改建议。 从1991年开始至今，Linux内核由10239行代码增加到了近1千万行代码，其中只有2%出自李纳斯之手。而且每天仍会新增约4752行代码，且有1671行代码会做出变更。 李纳斯喜欢有这么多的人给他从事这个事业的动力，他曾认为自己已接近于完成它了，但却始终没有真正做到这一点。人们一直给李纳斯更多继续的理由，以及更多困扰的棘手难题，这使得继续完善 Linux 变得更为有趣。否则，他可能早就干别的事情去了。 这并非耸人听闻的言论，而是李纳斯亲口所说。 生活的终极目标是快乐 李纳斯并不是离不开电脑，也不是离不开Linux。 早年上高中的时候，就因为感到有些课程比较有趣，比方说影响经济的因素，季风及季风成因等，可以让他放下了电脑去啃书本。 在与现任妻子塔芙同居的最初两周，他甚至都没有动过一下电脑，但他也并不为离开电脑而感到难受。 大学时期服兵役一年，离开电脑一年之久，他也没有对其有任何想念。 他曾花了数小时为他的宝马Z3选择合适的颜色而苦思冥想。原因无他，仅仅是觉得有意思而已。 在他看来，生活的进化过程主要分为三个阶段：生存、社会秩序和娱乐，而娱乐是生活的最高形式。他说，“你可以为事业而奋斗，然而最终，生活的终极目标是快乐。” 编程是他的乐趣，写出Linux也是乐趣使然。在无数次追求快乐而不得的纠结与无奈过后，Linux才得以成功面世。他无心做出一个举世瞩目的产品，也无意打造自己的商业帝国。微软把Linux视为Windows操作系统最大的竞争对手，而Linux的拥趸则无时不刻不在网上发言声称：Linux终将取代Windows。 但他却丝毫不为此挂心，每天在自己的卧房里（很难想象那里就是举世瞩目的Linux全球总部）做着自己感兴趣的事——为Linux编程。 -END-","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"dog.jpg/tags/技术/"}]},{"title":"pictures","slug":"pictures","date":"2018-03-25T08:57:56.000Z","updated":"2018-03-26T15:38:07.102Z","comments":true,"path":"2018/03/25/pictures/","link":"","permalink":"dog.jpg/2018/03/25/pictures/","excerpt":"","text":"2018年3月26日，连续雨天后的放晴 2018年3月10日，西安城墙一游 2018年1月8日，学校中心，冬景 2017年10月，秦岭下，古观音禅寺，去的有些晚，银杏叶大部分都落了，不过还是很美 古寺的历史，还是挺久远的 空气清新，内心平静 天气很好，心情很好 2019年9月14日，和同学一起绕学校转了一圈，真的挺大，这是在学校南边的家属区拍的，很净、很静 2017年9月17日，观光塔+情人坑 2017年9月踏进校园 2017年8月27日，夏天，家附近的一处山坡 2017年8月10日，家乡的河—洛河 充满想象 2017年7月29日，很傻，但很可爱（ _ ） 烈夏，暖风，白云，绿水，商洛 2017年7月24日，商洛，丹江河畔","categories":[],"tags":[{"name":"photo","slug":"photo","permalink":"dog.jpg/tags/photo/"}]},{"title":"音乐和视频","slug":"音乐和视频","date":"2018-03-24T12:06:44.000Z","updated":"2018-03-24T16:27:34.117Z","comments":true,"path":"2018/03/24/音乐和视频/","link":"","permalink":"dog.jpg/2018/03/24/音乐和视频/","excerpt":"","text":"插入音乐 代码如下 &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=380 height=500 src=&quot;http://music.163.com/m/song?id=432506345&amp;userid=590854430&quot;&gt; &lt;/iframe&gt; 插入视频 Idina Menze和Caleb Hyles激情对唱Let It Go： 代码如下 &lt;iframe height=300 width=380 src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot; frameborder=0 allowfullscreen&gt; &lt;/iframe&gt;","categories":[],"tags":[]},{"title":"gcc编译连接","slug":"gcc编译链接","date":"2018-03-23T12:08:57.000Z","updated":"2018-03-24T14:18:21.974Z","comments":true,"path":"2018/03/23/gcc编译链接/","link":"","permalink":"dog.jpg/2018/03/23/gcc编译链接/","excerpt":"","text":"在Windows的DOS下实现gcc编译和链接这里主要看的是两篇写的很详细的文章 C语言多文件编译初探（一） C语言多文件编译初探（二） 1.首先，你的Windows电脑的编译器需要是gcc,不清楚的话按win+r,输入cmd，打开DOS命令行界面。然后输入gcc -v,这个是用来查看你gcc版本的，如果提示不是内部或外部指令，则你的编译器不是gcc。反之，如果出现如下图片，则可以进行下一步了。 2.如果没有gcc，可以通过下载Dev-C++,使用其bin下的gcc.exe。在环境变量中配置Dev_C++下的bin。 3.此时就可以在DOS中使用gcc了。gcc可以将c/c++文件编译为.o文件，然后链接生成可执行文件.exe。4.接下来我们写两个源文件，一个头文件，用来模拟多文件编译过程。 //创建一个main.c文件 #include&lt;stdio.h&gt; int main() { fun(); return 0; } – //创建一个fun.c文件,用来创建函数 #include&lt;stdio.h&gt; void fun() { int a=3,b=6; printf(&quot;%d+%d=%d&quot;,a,b,a+b); } – //创建一个fun.h文件，用来声明fun()这个函数 //这个就很简单 void fun(); 5.接下来就到关键时刻了，先生成.o文件，命令是gcc -c fun.c main.c,前面-c是指只执行编译这一步，如果没有，就会直接生成.exe文件。这里是为了便于理解。执行完这一步，会发现源代码文件夹下有fun.o和main.o这两个文件，这就是目标文件，即二进制文件。下一步链接就需要这两个目标文件。 6.链接命令是gcc fun.o main.o,这个默认生成的.exe文件是a.exe,如果觉得这样的名字不好，可以自己命名，只需要在后面加个-o name.exe即可。例如gcc fun.o main.o -o mine.exe,执行完后源代码目录下就会有.exe文件生产。最终所有文件如下： 以上就是gcc编译链接多文件的流程","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"dog.jpg/tags/技术/"}]},{"title":"车牌识别","slug":"车牌识别","date":"2018-03-20T14:26:22.000Z","updated":"2018-03-24T14:19:25.359Z","comments":true,"path":"2018/03/20/车牌识别/","link":"","permalink":"dog.jpg/2018/03/20/车牌识别/","excerpt":"","text":"一、车牌定位代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;opencv2\\opencv.hpp&quot;#include &lt;iostream&gt;using namespace std; using namespace cv;int main()&#123; //定义，类似define string xmlPath = &quot;cascade.xml&quot;; //创建分类器对象 CascadeClassifier ccf; Mat img = imread(&quot;1.jpg&quot;); //加载训练文件 if (!ccf.load(xmlPath)) &#123; cout &lt;&lt; &quot;不能加载指定的xml文件&quot; &lt;&lt; endl; return 0; &#125; //创建一个容器保存检测出来的车牌 vector&lt;Rect&gt; faces; Mat gray; //转换成灰度图，因为harr特征从灰度图中提取 cvtColor(img, gray, CV_BGR2GRAY); //直方图均衡行 equalizeHist(gray, gray); //检测车牌 ccf.detectMultiScale(gray, faces, 1.1, 3, 0, Size(1, 10), Size(1000, 1000)); imshow(&quot;chepai&quot;, faces); for (vector&lt;Rect&gt;::const_iterator iter = faces.begin();iter != faces.end ();iter++) &#123; //画出车牌矩形 rectangle(img, *iter, Scalar(0, 0, 255), 2, 8); &#125; //imshow(&quot;rect&quot;, Rect); //resize(img, img, Size(1018, 550)); imshow(&quot;plate&quot;, img); waitKey(0); return 1;&#125; 结果如图 二、车牌字符识别 代码参考来自:https://www.cnblogs.com/chenzhefan/p/7629441.html 由于他使用的OpenCV版比较早，有些语法功能有稍微改变，但具体思路很详细。 ANN模型训练123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138void ann10(Mat&amp; testroi)&#123; const string fileform = &quot;*.png&quot;; const string perfileReadPath = &quot;E:\\\\vswork\\\\charSamples&quot;; const int sample_mun_perclass = 50;//训练字符每类数量 const int class_mun = 34;//训练字符类数 0-9 A-Z 除了I、O const int image_cols = 8; const int image_rows = 16; string fileReadName,fileReadPath; char temp[256]; float trainingData[class_mun*sample_mun_perclass][image_rows*image_cols] = &#123; &#123; 0 &#125; &#125;;//每一行一个训练样本 float labels[class_mun*sample_mun_perclass][class_mun] = &#123; &#123; 0 &#125; &#125;;//训练样本标签 for (int i = 0; i &lt;= class_mun - 1; i++)//不同类 &#123; //读取每个类文件夹下所有图像 int j = 0;//每一类读取图像个数计数 if (i &lt;= 9)//0-9 &#123; sprintf(temp, &quot;%d&quot;, i); //printf(&quot;%d\\n&quot;, i); &#125; else//A-Z &#123; sprintf(temp, &quot;%c&quot;, i + 55); //printf(&quot;%c\\n&quot;, i+55); &#125; fileReadPath = perfileReadPath + &quot;/&quot; + temp + &quot;/&quot; + fileform; cout &lt;&lt; &quot;文件夹&quot; &lt;&lt; fileReadPath &lt;&lt; endl; HANDLE hFile; LPCTSTR lpFileName = StringToWchar(fileReadPath);//指定搜索目录和文件类型，如搜索d盘的音频文件可以是&quot;D:\\\\*.mp3&quot; WIN32_FIND_DATA pNextInfo; //搜索得到的文件信息将储存在pNextInfo中; hFile = FindFirstFile(lpFileName, &amp;pNextInfo);//请注意是 &amp;pNextInfo , 不是 pNextInfo; if (hFile == INVALID_HANDLE_VALUE) &#123; continue;//搜索失败 &#125; //do-while循环读取 do &#123; if (pNextInfo.cFileName[0] == &apos;.&apos;)//过滤.和.. continue; j++;//读取一张图 //wcout&lt;&lt;pNextInfo.cFileName&lt;&lt;endl; //printf(&quot;%s\\n&quot;,WcharToChar(pNextInfo.cFileName)); //对读入的图片进行处理 Mat srcImage = imread(perfileReadPath + &quot;/&quot; + temp + &quot;/&quot; + WcharToChar(pNextInfo.cFileName), CV_LOAD_IMAGE_GRAYSCALE); Mat resizeImage; Mat trainImage; Mat result; resize(srcImage, resizeImage, Size(image_cols, image_rows), (0, 0), (0, 0), CV_INTER_AREA);//使用象素关系重采样。当图像缩小时候，该方法可以避免波纹出现 threshold(resizeImage, trainImage, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU); for (int k = 0; k&lt;image_rows*image_cols; ++k) &#123; trainingData[i*sample_mun_perclass + (j - 1)][k] = (float)trainImage.data[k]; //trainingData[i*sample_mun_perclass+(j-1)][k] = (float)trainImage.at&lt;unsigned char&gt;((int)k/8,(int)k%8);//(float)train_image.data[k]; //cout&lt;&lt;trainingData[i*sample_mun_perclass+(j-1)][k] &lt;&lt;&quot; &quot;&lt;&lt; (float)trainImage.at&lt;unsigned char&gt;(k/8,k%8)&lt;&lt;endl; &#125; &#125; while (FindNextFile(hFile, &amp;pNextInfo) &amp;&amp; j&lt;sample_mun_perclass);//如果设置读入的图片数量，则以设置的为准，如果图片不够，则读取文件夹下所有图片 &#125; // Set up training data Mat Mat trainingDataMat(class_mun*sample_mun_perclass, image_rows*image_cols, CV_32FC1, trainingData); cout &lt;&lt; &quot;trainingDataMat——OK！&quot; &lt;&lt; endl; // Set up label data for (int i = 0; i &lt;= class_mun - 1; ++i) &#123; for (int j = 0; j &lt;= sample_mun_perclass - 1; ++j) &#123; for (int k = 0; k &lt; class_mun; ++k) &#123; if (k == i) if (k == 18) &#123; labels[i*sample_mun_perclass + j][1] = 1; &#125; else if (k == 24) &#123; labels[i*sample_mun_perclass + j][0] = 1; &#125; else &#123; labels[i*sample_mun_perclass + j][k] = 1; &#125; else labels[i*sample_mun_perclass + j][k] = 0; &#125; &#125; &#125; Mat labelsMat(class_mun*sample_mun_perclass, class_mun, CV_32FC1, labels); cout &lt;&lt; &quot;labelsMat:&quot; &lt;&lt; endl; ofstream outfile(&quot;out.txt&quot;); outfile &lt;&lt; labelsMat; //cout&lt;&lt;labelsMat&lt;&lt;endl; cout &lt;&lt; &quot;labelsMat——OK！&quot; &lt;&lt; endl; //训练代码 cout &lt;&lt; &quot;training start....&quot; &lt;&lt; endl; CvANN_MLP bp; // Set up BPNetwork&apos;s parameters CvANN_MLP_TrainParams params; params.train_method = CvANN_MLP_TrainParams::BACKPROP; params.bp_dw_scale = 0.001; params.bp_moment_scale = 0.1; params.term_crit = cvTermCriteria(CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, 10000, 0.0001); //设置结束条件 //params.train_method=CvANN_MLP_TrainParams::RPROP; //params.rp_dw0 = 0.1; //params.rp_dw_plus = 1.2; //params.rp_dw_minus = 0.5; //params.rp_dw_min = FLT_EPSILON; //params.rp_dw_max = 50.; //Setup the BPNetwork Mat layerSizes = (Mat_&lt;int&gt;(1, 5) &lt;&lt; image_rows*image_cols, 128, 128, 128, class_mun); bp.create(layerSizes, CvANN_MLP::SIGMOID_SYM, 1.0, 1.0);//CvANN_MLP::SIGMOID_SYM //CvANN_MLP::GAUSSIAN //CvANN_MLP::IDENTITY cout &lt;&lt; &quot;training....&quot; &lt;&lt; endl; bp.train(trainingDataMat, labelsMat, Mat(), Mat(), params); bp.save(&quot;../bpcharModel.xml&quot;); //save classifier cout &lt;&lt; &quot;training finish...bpModel.xml saved &quot; &lt;&lt; endl; return;&#125; ANN+Predict1234567891011121314151617181920212223242526272829303132333435363738394041424344void predictann(Mat testroi)&#123; //测试神经网络 CvANN_MLP bp; bp.load(&quot;E:\\\\vswork\\\\CarNumRecog\\\\bpcharModel.xml&quot;); const int image_cols = 8; const int image_rows = 16; cout &lt;&lt; &quot;测试：&quot; &lt;&lt; endl; //Mat test_image = imread(&quot;E:\\\\vswork\\\\charSamples\\\\3.png&quot;, CV_LOAD_IMAGE_GRAYSCALE); Mat test_temp; resize(testroi, test_temp, Size(image_cols, image_rows), (0, 0), (0, 0), CV_INTER_AREA);//使用象素关系重采样。当图像缩小时候，该方法可以避免波纹出现 threshold(test_temp, test_temp, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU); Mat_&lt;float&gt;sampleMat(1, image_rows*image_cols); for (int i = 0; i&lt;image_rows*image_cols; ++i) &#123; sampleMat.at&lt;float&gt;(0, i) = (float)test_temp.at&lt;uchar&gt;(i / 8, i % 8); &#125; Mat responseMat; bp.predict(sampleMat, responseMat); Point maxLoc; double maxVal = 0; minMaxLoc(responseMat, NULL, &amp;maxVal, NULL, &amp;maxLoc); char temp[256]; if (maxLoc.x &lt;= 9)//0-9 &#123; sprintf(temp, &quot;%d&quot;, maxLoc.x); //printf(&quot;%d\\n&quot;, i); &#125; else//A-Z &#123; sprintf(temp, &quot;%c&quot;, maxLoc.x + 55); //printf(&quot;%c\\n&quot;, i+55); &#125; cout &lt;&lt; &quot;识别结果：&quot; &lt;&lt; temp &lt;&lt; &quot; 相似度:&quot; &lt;&lt; maxVal * 100 &lt;&lt; &quot;%&quot; &lt;&lt; endl; imshow(&quot;test_image&quot;, testroi); waitKey(0); return;&#125;","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"dog.jpg/tags/技术/"}]},{"title":"机器学习","slug":"机器学习","date":"2018-03-20T05:08:11.000Z","updated":"2018-03-24T14:19:57.767Z","comments":true,"path":"2018/03/20/机器学习/","link":"","permalink":"dog.jpg/2018/03/20/机器学习/","excerpt":"","text":"一、ANN、SVM模型训练及使用的代码提示：以下基于opencv3 由于我没有接触过类似于Tensorflow的深度学习框架，所以下面了解的知识还比较片面。除TensorFlow外，深度学习的框架还有：Caffe、Keras、CNTK、Torch7、MXNet、Leaf、Theano、DeepLearning4、Lasagne、Neon，等等 关于用TensorFlow训练模型的文章 opencv和Tensorflow的区别 OpenCV是计算机视觉库，Tensorflow是深度学习框架。 OpenCV包含了大量的图像处理和计算机视觉的算法，但是在机器学习方面明显不足，ML模块只有SVM，MLP（opencv的神经网络—多层感知器），kNN等有限的几种算法。dnn模块也是调用别的框架。 Tensorflow是专为深度学习而生，可以方便的实现各种深度学习算法。 二者不属于同一领域，做视觉用OpenCV，做深度学习用Tensorflow。或者二者结合做图像识别等等。 ANN模型训练 ANN模型使用参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int ANN_TEST()&#123; // 540 x 360 矩阵（为输入图片的尺寸） int smpW = 540; int smpH = 360; // 每个样本数据对应的输出 float labels[8] = &#123; 0,0,0,0,1,1,1,1 &#125;; //第一个数据：标签个数 Mat labelsMat(8, 1, CV_32FC1, labels); cout &lt;&lt; labelsMat &lt;&lt; endl; // 训练样本 Mat trainMat(8, smpW * smpH, CV_32FC1); for (int i = 0; i &lt; 2; i++) &#123; for (int j = 1; j &lt; 5; j++) &#123; //批量读取图片，因为8张图片，故没有转化为.txt格式 string path = format(&quot;%d%d.jpg&quot;, i, j); Mat img = imread(path, 0); if (img.empty()) &#123; return 0; &#125; int index1 = i * 4 + j - 1; float * trainData = trainMat.ptr&lt;float&gt;(index1); for (int h = 0; h &lt; smpH; h++) &#123; uchar * imgData = img.ptr&lt;uchar&gt;(h); for (int w = 0; w &lt; smpW; w++) &#123; int index2 = h*smpW + w; trainData[index2] = imgData[w]; &#125; &#125; &#125; &#125; //模型创建和参数设置 Ptr&lt;ANN_MLP&gt; bp = ANN_MLP::create(); //设置神经网络层数 Mat layerSizes = (Mat_&lt;int&gt;(1, 5) &lt;&lt; smpW * smpH, 128, 128, 128, 1); bp-&gt;setLayerSizes(layerSizes); bp-&gt;setTrainMethod(ANN_MLP::BACKPROP, 0.1, 0.1); bp-&gt;setActivationFunction(ANN_MLP::SIGMOID_SYM); bp-&gt;setTermCriteria(TermCriteria(TermCriteria::MAX_ITER, 10000, /*FLT_EPSILON*/1e-6)); // 保存训练好的神经网络参数 bool trained = bp-&gt;train(trainMat, ROW_SAMPLE, labelsMat); if (trained) &#123; bp-&gt;save(&quot;bp_param_bymyself.xml&quot;); &#125;&#125; ANN模型调用 123456789101112131415161718192021222324252627282930313233//创建并调用训练好的ANN神经网络Ptr&lt;ANN_MLP&gt; bp = ANN_MLP::load(&quot;bp_param.xml&quot;);for (int i = 0; i &lt; 2; i++)&#123; for (int j = 5; j &lt; 6; j++) &#123; Mat testMat(1, smpW * smpH, CV_32FC1); float * testData = testMat.ptr&lt;float&gt;(0); //读取图片 string path = format(&quot;%d%d.png&quot;, i, j); Mat img = imread(path, 0); for (int h = 0; h &lt; smpH; h++) &#123; uchar * imgData = img.ptr&lt;uchar&gt;(h); for (int w = 0; w &lt; smpW; w++) &#123; int index2 = h*smpW + w; testData[index2] = imgData[w] * 1.0; &#125; &#125; Mat responseMat; //通过模型进行预测 bp-&gt;predict(testMat, responseMat); float response = responseMat.ptr&lt;float&gt;(0)[0]; cout &lt;&lt; response &lt;&lt; endl; float * data = responseMat.ptr&lt;float&gt;(0); cout &lt;&lt; data[0] &lt;&lt; endl; waitKey(10); &#125;&#125; SVM模型训练123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int SVM()&#123; //训练2组数据，每组4帧 int labels[8] = &#123; 0, 0, 0, 0, 1, 1, 1, 1 &#125;; Mat labelsMat(8, 1, CV_32SC1, labels); //样本宽高 int smpW = 540; int smpH = 360; //将样本的值逐像素赋给训练图像 Mat trainMat(8, smpW * smpH, CV_32FC1); for (int i = 0; i &lt; 2; i++) &#123; for (int j = 1; j &lt; 5; j++) &#123; string path = format(&quot;%d%d.jpg&quot;, i, j); Mat img = imread(path, 0); int index1 = i * 4 + j - 1; float * trainData = trainMat.ptr&lt;float&gt;(index1); for (int h = 0; h &lt; smpH; h++) &#123; uchar * imgData = img.ptr&lt;uchar&gt;(h); for (int w = 0; w &lt; smpW; w++) &#123; int index2 = h*smpW + w; trainData[index2] = imgData[w]; &#125; &#125; &#125; &#125; Ptr&lt;SVM&gt; svm = SVM::create(); svm-&gt;setType(SVM::C_SVC); svm-&gt;setKernel(SVM::LINEAR); svm-&gt;setTermCriteria(TermCriteria(TermCriteria::MAX_ITER, 100, 1e-6)); ////设置训练数据 Ptr&lt;TrainData&gt; tData = TrainData::create(trainMat, ROW_SAMPLE, labelsMat); svm-&gt;train(tData); svm-&gt;save(&quot;SVM_data.xml&quot;);&#125; SVM模型调用12345678910111213141516171819202122232425262728293031323334int smpW = 540;int smpH = 360;//创建并调用SVM模型Ptr&lt;SVM&gt; svm = SVM::load(&quot;SVM_data.xml&quot;);cout &lt;&lt; &quot;测试&quot; &lt;&lt; endl;for (int i = 0; i &lt; 2; i++)&#123; for (int j = 5; j &lt; 6; j++) &#123; Mat testMat(1, smpW * smpH, CV_32FC1); float * testData = testMat.ptr&lt;float&gt;(0); string path = format(&quot;%d%d.png&quot;, i, j); Mat img = imread(path, 0); Canny(img, img, 50, 100); for (int h = 0; h &lt; smpH; h++) &#123; uchar * imgData = img.ptr&lt;uchar&gt;(h); for (int w = 0; w &lt; smpW; w++) &#123; int index2 = h*smpW + w; testData[index2] = imgData[w] * 1.0; &#125; &#125; Mat ret(1, 1, CV_32S); float response = svm-&gt;predict(testMat, ret); //进行预测，返回1或0 cout &lt;&lt; response &lt;&lt; endl; float * data = ret.ptr&lt;float&gt;(0); cout &lt;&lt; data[0] &lt;&lt; endl; waitKey(10); 二、神经网络训练及工作原理 1.原理 CNN原理解读 原理是：知道初始数据和需要的结果，分别用两个容器存储样本和标签数据，然后输入神经网络，神经网络通过大量数据的训练，使各层间的权值趋于稳定，直至模型训练完成。 目的：当给模型一个数据时，通过之前训练得出的模型，计算结果并输出。 2.训练流程的例子（ANN）前提需要准备好样本，标签的准备最为费时 创建神经网络 设置网络层数和神经元个数 创建两个容器，分别保存样本和标签 读取两个容器中的数据 开始训练模型 保存模型（数据少的话不太费时，多的话可能要一两天） 后期调用 3.样本和标签的批量处理由于样本和标签很多，所以要将他们放在一个地方，读取时就可以实现自动批量处理，这里以csv文件为例。csv是逗号分隔值文件格式，是一种用来存储数据的纯文本文件。目标为数字识别，保存样式为：一行两个数据，第一个为数字图片的存储路径（即样本），第二个为标签（就是图片的数字，比如0,1,2···）具体展示如下。 4.注意事项 ANN神经网络的输入层的端口数要等于样本的像素点，输出层端口数要等于label的个数 理论上网络越深则表达能力越强，能处理的训练数据也更多，但训练算法未必支持 机器学习要想生效，必须满足一个条件，就是目标问题对已有数据可解 三、车牌识别（HyperLPR） 车牌识别中用到机器学习的有两个地方—–&gt;1. 车牌定位 2.车牌字符识别 车牌定位 车牌字符识别","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"dog.jpg/tags/技术/"}]},{"title":"Markdown_note","slug":"Markdown-note","date":"2018-03-18T15:14:21.000Z","updated":"2018-03-26T05:27:16.322Z","comments":true,"path":"2018/03/18/Markdown-note/","link":"","permalink":"dog.jpg/2018/03/18/Markdown-note/","excerpt":"","text":"第二篇 Markdown学习笔记By Lijie上面是一条细横线 也有粗横线与之对应： 是--- 序号部分 与文字间要有空格 其他也没什么重要的 就是这样 着重号 *和-功能一样 加粗 此处也可用快捷键ctrl+B 倾斜 快捷键ctrl+I 代码部分 ctrl+K 删除线 此处不能显示我也不知怎到原因 此处还有引用 千山鸟飞绝，万径人踪灭 图片插入 超出我的预料，特别方便 《春江花月夜》春江潮水连海平，海上明月共潮生。 滟滟随波千万里，何处春江无月明！ 江流宛转绕芳甸，月照花林皆似霰； 空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。 江畔何人初见月？江月何年初照人？ 人生代代无穷已，江月年年只相似。 不知江月待何人，但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。 谁家今夜扁舟子？何处相思明月楼？ 可怜楼上月徘徊，应照离人妆镜台。 玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。 鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。 江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。 不知乘月几人归，落月摇情满江树。 我再试试输入另外一张图片 圆括号内写图片路径 表格 | 看看 | 可是 | | — | — | | 55 | 66 | 同样是不能显示 最后是链接 百度 自己尝试 我的Github 到此基本功能学习完了","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"dog.jpg/tags/学习笔记/"}]},{"title":"第一次尝试","slug":"第一次尝试","date":"2018-03-16T16:25:59.000Z","updated":"2018-03-24T16:27:49.063Z","comments":true,"path":"2018/03/17/第一次尝试/","link":"","permalink":"dog.jpg/2018/03/17/第一次尝试/","excerpt":"","text":"#很高兴，今天可以自己搭建博客了 ## 1.之前尝试过搭建，都因为工具的原因一直出错。 2.今天下午在ubuntu上尝试，但hexo无法正常下载。然后又用Windows的Git搭建，出现的问题更多。 3.最后在网上看到一篇博客—&gt;http:////blog.csdn.net/gdutxiaoxu/article/details/535760184.他直接使用Windows的DOS,具体操作很详细，过程也能看懂。 博客的发布也很简单：hexo d -g 生成及部署 此处载入一张图片，以表心情 5.希望自己稍后能学会在Linux上搭建博客。 ##","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"dog.jpg/tags/随笔/"}]},{"title":"Hello World","slug":"Hello-World","date":"2018-03-16T11:32:59.000Z","updated":"2018-03-25T08:51:16.756Z","comments":true,"path":"2018/03/16/Hello-World/","link":"","permalink":"dog.jpg/2018/03/16/Hello-World/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}